import { create } from 'zustand';

/**
 * Shape of a single error item stored in the global error store.
 *
 * This represents one “message” that can be rendered by the
 * `ErrorNotifications` component as a toast/notification.
 */
export interface AppError {
    /** Unique identifier generated by the store (not provided by the caller). */
    id: string;
    /** Human‑readable description of what went wrong. */
    message: string;
    /** Optional short title shown above the message (e.g. "Network error"). */
    title?: string;
    /** Visual severity level that can influence styling. */
    type?: 'error' | 'warning' | 'info';
    /**
     * When `false`, the notification will stay visible until user closes it.
     * When `true` or `undefined`, it will auto‑dismiss after a timeout.
     */
}

/**
 * Internal Zustand state for the error store.
 *
 * Exposes:
 *  - current list of errors (`errors`)
 *  - methods to add a new error (`addError`)
 *  - method to remove an existing error by id (`removeError`)
 */
interface ErrorState {
    errors: AppError[];
    addError: (error: Omit<AppError, 'id'>) => void;
    removeError: (id: string) => void;
}

/**
 * Global error store used by the client-side error system.
 *
 * - Any part of the app can call `useErrorStore.getState().addError(...)`
 *   or use helpers like `throwError(...)` to push an error into this store.
 * - `ErrorNotifications` subscribes to this store and renders all errors as
 *   notifications that can be closed by the user.
 * - Errors are, by default, removed automatically after 5 seconds, unless
 */
export const useErrorStore = create<ErrorState>((set) => ({
    errors: [],
    addError: (error) => {
        // Generate a simple random id; good enough for transient UI messages.
        const id = Math.random().toString(36).substring(7);
        set((state) => ({ errors: [...state.errors, { ...error, id }] }));
    },
    removeError: (id) => set((state) => ({
        errors: state.errors.filter((e) => e.id !== id)
    })),
}));

/**
 * Custom error type used to mark errors that have already been
 * handled and pushed into the error store.
 *
 * Global listeners (in `ErrorNotifications`) can detect `HandledError`
 * and skip adding a second notification for the same error, which
 * prevents double-reporting when `throwError` is used.
 */
export class HandledError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'HandledError';
    }
}

/**
 * Convenience helper for places where you would normally use `throw new Error`.
 *
 * Instead of:
 *   throw new Error("Something went wrong");
 *
 * you can do:
 *   throwError("Something went wrong", "Optional title");
 *
 * This will:
 *  1) push an error into the global `useErrorStore` so that
 *     `ErrorNotifications` can show a toast, and
 *  2) throw a `HandledError`, which can still be caught by React/Next.js
 *     error boundaries, but will be ignored by the global window listeners
 *     (to avoid duplicate notifications).
 *
 * @param message - Human‑readable error message for both the notification and the thrown error.
 * @param title   - Optional short title used in the notification UI (defaults to "Error").
 * @throws {HandledError} Always throws after adding the error to the store.
 */
export const throwError = (message: string, title?: string) => {
    useErrorStore.getState().addError({
        title: title || 'Error',
        message,
        type: 'error'
    });
    throw new HandledError(message);
}
